                            | # PIPE implementation test for btfnt
                            | ## Side-note: stack maintenance not followed. This means the code 
                            | ## can't safely be embedded in other programs.
                            | 
                            | 
                            | ## Pipeline: At a given cycle, the signals generated in each stage can be
                            | ## wired to any other stage. 
                            | 
                            | ## Selection logic in the F stage, determines the current instruction and
                            | ## whether to correct a branch whose determining jump is now in the M stage.
                            | ## The forwarding logic feeding M_valA from M carries the correct address to
                            | ## the F stage select logic. The address carried by M_valA has been 
                            | ## determined in the E stage of the previous cycle. 
                            | ## This logic block must coherently resolve correct prediction, and wrong
                            | ## prediction. This occurs when the predicted cond jmp has passed from 
                            | ## E stage into M stage. In order to do this:
                            | #
                            | ## Verify that the instr in M is a conditional jump.
                            | ## Check M pipe regs to determine if the jump is mispredicted bt, or fnt.
                            | ## The cond jmp's valP is led through the pipeline via AluA+0 into M_valE
                            | ## so that it can be compared against whatever arrives in M_valA.
                            | ## When checking for the backwards taken condition:
                            | ## in case it is correctly predicted, M_Cnd=1 and M_valA=???
                            | 	# predPC selected
                            | ## in case it is wrongly predicted, M_Cnd=0 and M_valA=valP
                            | 	# M_valA selected
                            | ## When checking for the forwards not taken condition:
                            | ## in case it is correctly predicted, M_Cnd=0 and M_valA=???
                            | 	# predPC selected
                            | ## in case it is wrongly predicted, M_Cnd=1 and M_valA=valC
                            | 	# M_valA selected
                            | 	
                            | 
                            | 
                            | ## Prediction logic predPC determines based on the current instruction what
                            | ## the NEXT one should be. When that logic fails, selectPC in F stage opts
                            | ## for the forwarded value from M stage.
                            | 
                            | ## Forwarding logic determines which "corrective" address will be fed into 
                            | ## M_valA in the next cycle. This value is also used to detect whether or 
                            | ## not a misprediction has occurred.
                            | 
                            | ## Pipe control logic must ensure that stalling and bubbles are injected
                            | ## under correct conditions; for btfnt misprediction, this means deciding
                            | ## to inject them based on signals generated by the mispredicted conditional
                            | ## jump in the E stage, so that the injection occurs the next cycle as 
                            | ## the jump enters the M stage, the same cycle where the F stage selects
                            | ## the correct forwarded address M_valA.
                            | 
                            | ### Test code during debugging:
                            | # Debugging done in GUI version.
                            | 
                            | # overall test of pipeline:
                            | # 24/64 fail regression jtests when only one mispredicted condition in
                            | # selection.
                            | # 24/64 fail regression jtest when tried to include both misprediction
                            | # conditions. Also, asumr ISA check fails.
                            | # When correction1 is implemented, 12/64 jtests fail. Improve it?
                            | # See which regression tests fail and at which code, and integrate
                            | # that code into the test here?
                            | # When correction2 is implemented, all tests pass.
                            | 
                            | ## issues:
                            | # The 2cycle Fstall appears when the first cond jmp goes E->M
                            | # Maybe what happens is D and F take the same instr for some reason,
                            | # overlapping.
                            | # This cond jmp is forward not taken, correctly.
                            | 
                            | # next cond jmp is backward taken correctly, but again when 
                            | # the cond jmp goes E->M it bugs, redirecting Fstage to right
                            | # after the condjmp. Selection logic seems to pick M_valA which
                            | # carries valP, "correcting" to it in the backwards taken case.
                            | # This is handled by ignoring the case where fnt needs to be 
                            | # corrected and valC==valP. (correction1)
                            | 
                            | 	# Situation: when fnt is correctly predicted, once the
                            | 	# cond jmp reaches E, valP is fed into M_valA, since
                            | 	# there is no strict need to feed E_valC as correction, 
                            | 	# and the e_Cnd=M_Cnd is 0. However, this combination of values
                            | 	# is that for which "mispredicted backwards taken" is detected
                            | 	# in F's selection logic. This leads to selecting M_valA in F
                            | 	# despite there being no need for it, meaning that the 
                            | 	# selected address is the one right after the jump, effectively
                            | 	# stalling F for two cycles.
                            | 	# In order to circumvent this, encode the "fnt correct"
                            | 	# logic explicitly to feed E_valC into M_valA. This causes
                            | 	# neither misprediction to be detected in selection logic, 
                            | 	# since the "bt mispredicted" logic now fails in F stage.
                            | 
                            | # uncond jmp and call and ret all predicted, executed correctly.
                            | 
                            | 
                            | #### Code here. Execution begins at address 0. ####
0x000:                      | 	.pos 0 
0x000: 30f40004000000000000 | 	irmovq stack, %rsp  	# Set up stack pointer  
0x00a: 801400000000000000   | 	call main		# Execute main program
0x013: 00                   | 	halt			# Terminate program 
                            | 
                            | # main program
0x014: 800d01000000000000   | main:	call btfnttst		# nttst()
0x01d: 90                   | 	ret 
                            | 	
                            | /* $begin btfnt test */
                            | 
                            | # long dummy()
0x100:                      | 	.pos 0x100
0x100: 30f00400000000000000 | dummy:	irmovq $4, %rax
0x10a: 10                   | 	nop
0x10b: 10                   | 	nop
0x10c: 90                   | 	ret
                            | 
                            | # long btfnttst()
0x10d:                      | btfnttst:	
0x10d: 6300                 | 	xorq %rax, %rax	# rax = 0
0x10f: 6322                 | 	xorq %rdx, %rdx	# rdx = 0
                            | 	
0x111: 702e01000000000000   | 	jmp UJ1
0x11a: 30fa3300000000000000 | 	irmovq $0x33, %r10	# never executed, never in pipeline
0x124: 30fa3300000000000000 | 	irmovq $0x33, %r10	# never executed, never in pipeline
                            | 		
0x12e: 10                   | UJ1:	nop			# should be passed through without F_stall
0x12f: 10                   | 	nop
0x130: 10                   | 	nop
0x131: 704e01000000000000   | 	jmp UJ2		# Must be predicted as taken
0x13a: 30fa3300000000000000 | 	irmovq $0x33, %r10	# never executed, never in pipeline
0x144: 30fa3300000000000000 | 	irmovq $0x33, %r10	# never executed, never in pipeline
                            | 	
0x14e: 30f10200000000000000 | UJ2:	irmovq $0x2, %rcx	# Should be in the pipeline after jmp
0x158: 30f30100000000000000 | 	irmovq $0x1, %rbx
0x162: 10                   | 	nop			# To avoid a confusing fetch stall due to reg.
0x163: 10                   | 	nop
0x164: 6132                 | 	subq %rbx, %rdx	# rdx is negative
0x166: 769b01000000000000   | 	jg FNT1		# must be predicted as not-taken ...
0x16f: 10                   | 	nop			# ... so the nops should fill the pipeline
0x170: 10                   | 	nop			# Proceed because FNT1 shouldn't be taken.
0x171: 10                   | 	nop
0x172: 800001000000000000   | 	call dummy		# Must be predicted as called; ValC=0x100?
                            | 				# Further, it must set rax to 4
                            | 				
0x17b: 6010                 | 	addq %rcx, %rax	# Should amount to 6.
0x17d: 76b001000000000000   | 	jg FNT2		# Should be predicted not taken; then fix,take
0x186: 30fb2200000000000000 | 	irmovq $0x22, %r11	# Should be in the pipeline, but cancelled.
0x190: 30fb2200000000000000 | 	irmovq $0x22, %r11	# Should be in the pipeline, but cancelled.
0x19a: 00                   | 	halt
                            | 	
0x19b: 30fa3300000000000000 | FNT1:	irmovq $0x33, %r10	# never executed, never in pipeline
0x1a5: 30fa3300000000000000 | 	irmovq $0x33, %r10	# never executed, never in pipeline
0x1af: 00                   | 	halt
                            | 	
0x1b0: 6200                 | FNT2:	andq %rax, %rax	# No change to registers, CC set?
0x1b2: 30f30500000000000000 | 	irmovq $0x5, %rbx	# Set up a loop for backwards taken.
0x1bc: 30f90100000000000000 | 	irmovq $0x1, %r9
0x1c6: 6200                 | BT1:	andq %rax, %rax
0x1c8: 10                   | 	nop
0x1c9: 10                   | 	nop
0x1ca: 10                   | 	nop
0x1cb: 10                   | 	nop
0x1cc: 6193                 | 	subq %r9, %rbx
0x1ce: 75c601000000000000   | 	jge BT1
0x1d7: 10                   | 	nop
0x1d8: 10                   | 	nop
0x1d9: 10                   | 	nop
0x1da: 10                   | 	nop
0x1db: 10                   | 	nop
0x1dc: 90                   | 	ret
                            | 	
                            | 	
                            | /* $end btfnt test */
                            | 
                            | # The stack starts here and grows to lower addresses
0x400:                      | 	.pos 0x400		
0x400:                      | stack:	 
