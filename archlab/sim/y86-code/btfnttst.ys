# PIPE implementation test for btfnt
## Side-note: stack maintenance not followed. This means the code 
## can't safely be embedded in other programs.


## Pipeline: At a given cycle, the signals generated in each stage can be
## wired to any other stage. 

## Selection logic in the F stage, determines the current instruction and
## whether to correct a branch whose determining jump is now in the M stage.
## The forwarding logic feeding M_valA from M carries the correct address to
## the F stage select logic. The address carried by M_valA has been 
## determined in the E stage of the previous cycle. 
## This logic block must coherently resolve correct prediction, and wrong
## prediction. This occurs when the predicted cond jmp has passed from 
## E stage into M stage. In order to do this:
#
## Verify that the instr in M is a conditional jump.
## Check M pipe regs to determine if the jump is mispredicted bt, or fnt.
## The cond jmp's valP is led through the pipeline via AluA+0 into M_valE
## so that it can be compared against whatever arrives in M_valA.
## When checking for the backwards taken condition:
## in case it is correctly predicted, M_Cnd=1 and M_valA=???
	# predPC selected
## in case it is wrongly predicted, M_Cnd=0 and M_valA=valP
	# M_valA selected
## When checking for the forwards not taken condition:
## in case it is correctly predicted, M_Cnd=0 and M_valA=???
	# predPC selected
## in case it is wrongly predicted, M_Cnd=1 and M_valA=valC
	# M_valA selected
	


## Prediction logic predPC determines based on the current instruction what
## the NEXT one should be. When that logic fails, selectPC in F stage opts
## for the forwarded value from M stage.

## Forwarding logic determines which "corrective" address will be fed into 
## M_valA in the next cycle. This value is also used to detect whether or 
## not a misprediction has occurred.

## Pipe control logic must ensure that stalling and bubbles are injected
## under correct conditions; for btfnt misprediction, this means deciding
## to inject them based on signals generated by the mispredicted conditional
## jump in the E stage, so that the injection occurs the next cycle as 
## the jump enters the M stage, the same cycle where the F stage selects
## the correct forwarded address M_valA.

### Test code during debugging:
# Debugging done in GUI version.

# overall test of pipeline:
# 24/64 fail regression jtests when only one mispredicted condition in
# selection.
# 24/64 fail regression jtest when tried to include both misprediction
# conditions. Also, asumr ISA check fails.
# When correction1 is implemented, 12/64 jtests fail. Improve it?
# See which regression tests fail and at which code, and integrate
# that code into the test here?
# When correction2 is implemented, all tests pass.

## issues:
# The 2cycle Fstall appears when the first cond jmp goes E->M
# Maybe what happens is D and F take the same instr for some reason,
# overlapping.
# This cond jmp is forward not taken, correctly.

# next cond jmp is backward taken correctly, but again when 
# the cond jmp goes E->M it bugs, redirecting Fstage to right
# after the condjmp. Selection logic seems to pick M_valA which
# carries valP, "correcting" to it in the backwards taken case.
# This is handled by ignoring the case where fnt needs to be 
# corrected and valC==valP. (correction1)

	# Situation: when fnt is correctly predicted, once the
	# cond jmp reaches E, valP is fed into M_valA, since
	# there is no strict need to feed E_valC as correction, 
	# and the e_Cnd=M_Cnd is 0. However, this combination of values
	# is that for which "mispredicted backwards taken" is detected
	# in F's selection logic. This leads to selecting M_valA in F
	# despite there being no need for it, meaning that the 
	# selected address is the one right after the jump, effectively
	# stalling F for two cycles.
	# In order to circumvent this, encode the "fnt correct"
	# logic explicitly to feed E_valC into M_valA. This causes
	# neither misprediction to be detected in selection logic, 
	# since the "bt mispredicted" logic now fails in F stage.

# uncond jmp and call and ret all predicted, executed correctly.


#### Code here. Execution begins at address 0. ####
	.pos 0 
	irmovq stack, %rsp  	# Set up stack pointer  
	call main		# Execute main program
	halt			# Terminate program 

# main program
main:	call btfnttst		# nttst()
	ret 
	
/* $begin btfnt test */

# long dummy()
	.pos 0x100
dummy:	irmovq $4, %rax
	nop
	nop
	ret

# long btfnttst()
btfnttst:	
	xorq %rax, %rax	# rax = 0
	xorq %rdx, %rdx	# rdx = 0
	
	jmp UJ1
	irmovq $0x33, %r10	# never executed, never in pipeline
	irmovq $0x33, %r10	# never executed, never in pipeline
		
UJ1:	nop			# should be passed through without F_stall
	nop
	nop
	jmp UJ2		# Must be predicted as taken
	irmovq $0x33, %r10	# never executed, never in pipeline
	irmovq $0x33, %r10	# never executed, never in pipeline
	
UJ2:	irmovq $0x2, %rcx	# Should be in the pipeline after jmp
	irmovq $0x1, %rbx
	nop			# To avoid a confusing fetch stall due to reg.
	nop
	subq %rbx, %rdx	# rdx is negative
	jg FNT1		# must be predicted as not-taken ...
	nop			# ... so the nops should fill the pipeline
	nop			# Proceed because FNT1 shouldn't be taken.
	nop
	call dummy		# Must be predicted as called; ValC=0x100?
				# Further, it must set rax to 4
				
	addq %rcx, %rax	# Should amount to 6.
	jg FNT2		# Should be predicted not taken; then fix,take
	irmovq $0x22, %r11	# Should be in the pipeline, but cancelled.
	irmovq $0x22, %r11	# Should be in the pipeline, but cancelled.
	halt
	
FNT1:	irmovq $0x33, %r10	# never executed, never in pipeline
	irmovq $0x33, %r10	# never executed, never in pipeline
	halt
	
FNT2:	andq %rax, %rax	# No change to registers, CC set?
	irmovq $0x5, %rbx	# Set up a loop for backwards taken.
	irmovq $0x1, %r9
BT1:	andq %rax, %rax
	nop
	nop
	nop
	nop
	subq %r9, %rbx
	jge BT1
	nop
	nop
	nop
	nop
	nop
	ret
	
	
/* $end btfnt test */

# The stack starts here and grows to lower addresses
	.pos 0x400		
stack:	 
