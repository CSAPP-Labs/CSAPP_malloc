                            | #/* $begin ncopy-ys */
                            | ##################################################################
                            | # ncopy.ys - Copy a src block of len words to dst.
                            | # Return the number of positive words (>0) contained in src.
                            | #
                            | # Include your name and ID here.
                            | #
                            | # Describe how and why you modified the baseline code.
                            | #
                            | ##################################################################
                            | # Do not modify this portion
                            | # Function prologue.
                            | # %rdi = src, %rsi = dst, %rdx = len
0x000:                      | ncopy:
                            | 
                            | ##################################################################
                            | # You can modify this portion: 
                            | 
                            | ## Initial improvements:
                            | # Using iaddq for incrementing to reduce the number of instructions.
                            | # Ensuring that jumps are directed at the code branches more likely
                            | # to be taken.
                            | 
                            | ## Deeper improvements: 
                            | # Loop unrolling.
                            | # NOTE: the argument in favour of this approach is that memory is 
                            | # more abundant than processing capacity. 
                            | # Processing N elements at a time in the main loop. Prior to entering the 
                            | # loop, process an optional element in case the length is odd. This 
                            | # approach condenses incrementation of src/dest/len into fewer instructions
                            | # with larger constants. 
                            | # Expanding the approach to doing more elements in the loop would involve
                            | # checking the remaining length at the end of each iteration, but if done 
                            | # by copying this code, the optimization gains are diminishing if done 
                            | # without further improvements: 
                            | # N=10 CPE=8.41. N=8 CPE=8.49. N=6 CPE=8.66. N=2+odd1 CPE=8.9.
                            | 
                            | # An improvement in check-if-neg. (tested via benchmark.pl)
                            | # First checking if there is ONE negative in a pair (xorq r10,r11 is then
                            | # neg) and thus skipping the second check altogether in roughly 50% of all
                            | # cases. This yields CPE=8.23 with the N=2+odd1 unrolling.
                            | # Combining this improvement with the verbose N=6+ yields CPE=7.92, N=10
                            | # about CPE 7.8, but again the returns are diminishing with more N.
                            | 
                            | ## Potential improvements:
                            | # Further optimization may involve checking the incremented src/dest 
                            | # against the ptr of the end element. But in the absence of hard-coded 
                            | # array length, and no shifts in the ISA, the way to compute len*8 may 
                            | # be to store it in memory, next to an 8-byte zero, then somehow misalign 
                            | # the read by +3 bytes,  which would have the effect of a 3-bit shift.
                            | 
                            | 
                            | 	# Loop header
0x000: 6300                 | 	xorq %rax,%rax		# count = 0;
                            | 	
                            | 	# Check if the array can be processed in blocks of N
0x002: 202b                 | Mass:	rrmovq %rdx, %r11
0x004: c0fbf6ffffffffffffff | 	iaddq $-10, %r11
0x00e: 760101000000000000   | 	jg Nth
                            | 		
                            | 	# # # # # # # BASIC N=2+ODD1
                            | 	
                            | 	# if odd, do one element then goto Npos. else cont. to loop
0x017: 30fb0100000000000000 | 	irmovq $1, %r11
0x021: 622b                 | 	andq %rdx, %r11
0x023: 717300000000000000   | 	jle Even		
                            | 	
                            | 	# put into Npos and handle increments instead?
0x02c: 50a70000000000000000 | 	mrmovq $0(%rdi), %r10	# read val from src...
0x036: 40a60000000000000000 | 	rmmovq %r10, $0(%rsi)	# ...and store it to dst	
0x040: c0f70800000000000000 | 	iaddq $8, %rdi		# src++	
0x04a: c0f60800000000000000 | 	iaddq $8, %rsi		# dst++	
0x054: c0f2ffffffffffffffff | 	iaddq $-1, %rdx	# len--
                            | 	
                            | 	# Instead, check neg at Npos or Neg1 and share that step with loop?
                            | 	# Need a better way to check if negative and increment
0x05e: 62aa                 | 	andq %r10, %r10
0x060: 717300000000000000   | 	jle Even
0x069: c0f00100000000000000 | 	iaddq $1, %rax
                            | 
                            | 	
0x073: 6222                 | Even:	andq %rdx,%rdx		# len <= 0?
0x075: 767f00000000000000   | 	jg Loop		# if so, goto Done:assume arg len always >0
0x07e: 90                   | 	ret
                            | 
0x07f: 50a70000000000000000 | Loop:	mrmovq $0(%rdi), %r10	# read val from src...
0x089: 40a60000000000000000 | 	rmmovq %r10, $0(%rsi)	# ...and store it to dst
                            | 	
0x093: 50b70800000000000000 | 	mrmovq $8(%rdi), %r11	# read val from src...
0x09d: 40b60800000000000000 | 	rmmovq %r11, $8(%rsi)	# ...and store it to dst	
                            | 	
0x0a7: c0f71000000000000000 | 	iaddq $16, %rdi	# src++	
0x0b1: c0f61000000000000000 | 	iaddq $16, %rsi	# dst++
                            | 	
                            | 	# check if either element is negative; %r11 changes
0x0bb: 63ab                 | 	xorq %r10, %r11	# val <= 0? 
0x0bd: 72db00000000000000   | 	jl Add1
0x0c6: 62aa                 | 	andq %r10, %r10
0x0c8: 72e500000000000000   | 	jl Npos		# if neither negative, skip adds
0x0d1: c0f00100000000000000 | 	iaddq $1, %rax		# count++
0x0db: c0f00100000000000000 | Add1:	iaddq $1, %rax		# count++
                            | 
0x0e5: c0f2feffffffffffffff | Npos:	iaddq $-2, %rdx	# len-- should also check len > 0 by set cc?
0x0ef: 767f00000000000000   | 	jg Loop		# if so, goto Loop:
0x0f8: 70c202000000000000   | 	jmp Done		# Not needed if N< (2+odd1)
                            | 	
                            | 	# # # # # # # END BASIC N=2+ODD1
                            | 	
                            | 	
                            | 	
                            | 	
                            | 	# Process N elements in blocks of 2 ...
0x101: 50a70000000000000000 | Nth:	mrmovq $0(%rdi), %r10	# read val from src...
0x10b: 40a60000000000000000 | 	rmmovq %r10, $0(%rsi)	# ...and store it to dst
                            | 	
0x115: 50b70800000000000000 | 	mrmovq $8(%rdi), %r11	# read val from src...
0x11f: 40b60800000000000000 | 	rmmovq %r11, $8(%rsi)	# ...and store it to dst
                            | 	
                            | 	# check if either element is negative; %r11 changes
0x129: 63ab                 | 	xorq %r10, %r11	# val <= 0? 
0x12b: 724901000000000000   | 	jl Add2
0x134: 62aa                 | 	andq %r10, %r10
0x136: 725301000000000000   | 	jl Cont1		# if neither negative, skip adds
0x13f: c0f00100000000000000 | 	iaddq $1, %rax		# count++
0x149: c0f00100000000000000 | Add2:	iaddq $1, %rax		# count++
                            | 
                            | 
0x153: 50a71000000000000000 | Cont1:	mrmovq $16(%rdi), %r10	# read val from src...
0x15d: 40a61000000000000000 | 	rmmovq %r10, $16(%rsi)	# ...and store it to dst
                            | 	
0x167: 50b71800000000000000 | 	mrmovq $24(%rdi), %r11	# read val from src...
0x171: 40b61800000000000000 | 	rmmovq %r11, $24(%rsi)	# ...and store it to dst
                            | 	
                            | 	# check if either element is negative; %r11 changes
0x17b: 63ab                 | 	xorq %r10, %r11	# val <= 0? 
0x17d: 729b01000000000000   | 	jl Add3
0x186: 62aa                 | 	andq %r10, %r10
0x188: 72a501000000000000   | 	jl Cont2		# if neither negative, skip adds
0x191: c0f00100000000000000 | 	iaddq $1, %rax		# count++
0x19b: c0f00100000000000000 | Add3:	iaddq $1, %rax		# count++
                            | 
                            | 
0x1a5: 50a72000000000000000 | Cont2:	mrmovq $32(%rdi), %r10	# read val from src...
0x1af: 40a62000000000000000 | 	rmmovq %r10, $32(%rsi)	# ...and store it to dst
                            | 	
0x1b9: 50b72800000000000000 | 	mrmovq $40(%rdi), %r11	# read val from src...
0x1c3: 40b62800000000000000 | 	rmmovq %r11, $40(%rsi)	# ...and store it to dst
                            | 	
                            | 	# check if either element is negative; %r11 changes
0x1cd: 63ab                 | 	xorq %r10, %r11	# val <= 0? 
0x1cf: 72ed01000000000000   | 	jl Add4
0x1d8: 62aa                 | 	andq %r10, %r10
0x1da: 72f701000000000000   | 	jl Cont3		# if neither negative, skip adds
0x1e3: c0f00100000000000000 | 	iaddq $1, %rax		# count++
0x1ed: c0f00100000000000000 | Add4:	iaddq $1, %rax		# count++
                            | 
                            | 
0x1f7: 50a73000000000000000 | Cont3:	mrmovq $48(%rdi), %r10	# read val from src...
0x201: 40a63000000000000000 | 	rmmovq %r10, $48(%rsi)	# ...and store it to dst
                            | 	
0x20b: 50b73800000000000000 | 	mrmovq $56(%rdi), %r11	# read val from src...
0x215: 40b63800000000000000 | 	rmmovq %r11, $56(%rsi)	# ...and store it to dst
                            | 	
                            | 	# check if either element is negative; %r11 changes
0x21f: 63ab                 | 	xorq %r10, %r11	# val <= 0? 
0x221: 723f02000000000000   | 	jl Add5
0x22a: 62aa                 | 	andq %r10, %r10
0x22c: 724902000000000000   | 	jl Cont4		# if neither negative, skip adds
0x235: c0f00100000000000000 | 	iaddq $1, %rax		# count++
0x23f: c0f00100000000000000 | Add5:	iaddq $1, %rax		# count++
                            | 
                            | 
0x249: 50a74000000000000000 | Cont4:	mrmovq $64(%rdi), %r10	# read val from src...
0x253: 40a64000000000000000 | 	rmmovq %r10, $64(%rsi)	# ...and store it to dst
                            | 	
0x25d: 50b74800000000000000 | 	mrmovq $72(%rdi), %r11	# read val from src...
0x267: 40b64800000000000000 | 	rmmovq %r11, $72(%rsi)	# ...and store it to dst
                            | 	
                            | 	# check if either element is negative; %r11 changes
0x271: 63ab                 | 	xorq %r10, %r11	# val <= 0? 
0x273: 729102000000000000   | 	jl Add6
0x27c: 62aa                 | 	andq %r10, %r10
0x27e: 729b02000000000000   | 	jl Cont5		# if neither negative, skip adds
0x287: c0f00100000000000000 | 	iaddq $1, %rax		# count++
0x291: c0f00100000000000000 | Add6:	iaddq $1, %rax		# count++
                            | 
                            | 
                            | 
0x29b: c0f75000000000000000 | Cont5:	iaddq $80, %rdi	# src++	
0x2a5: c0f65000000000000000 | 	iaddq $80, %rsi	# dst++
0x2af: c0f2f6ffffffffffffff | 	iaddq $-10, %rdx	# len-- should also check len > 0 by set cc?
0x2b9: 760200000000000000   | 	jg Mass		# Check if another block
                            | 
                            | 
                            | ##################################################################
                            | # Do not modify the following section of code
                            | # Function epilogue.
0x2c2:                      | Done:
0x2c2: 90                   | 	ret
                            | ##################################################################
                            | # Keep the following label at the end of your function
0x2c3:                      | End:
                            | #/* $end ncopy-ys */
